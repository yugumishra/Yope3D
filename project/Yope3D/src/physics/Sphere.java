package physics;

import java.util.ArrayList;
import java.util.List;

import org.joml.Vector3f;

import visual.Mesh;
import visual.Util;

//this class encapsulates the behavior of a sphere object
//this class extends mesh to provide additional functionality beyond rendering
//like collisions and mesh generation
public class Sphere extends Mesh {
	
	//create private constructor the creates based on mesh constuctor
	private Sphere(float[] vertices, int[] indices) {
		super(vertices, indices);
	}
	
	//public constructor that creates mesh and indices based on input
	public static Sphere genSphere(float radius, int subdiv) {
		//this code will generate an icosphere
		//an icosphere is a sphere approximation generated by taking an icosahedron, subdividing each triangle
		//into 4, then projecting the vertices onto the desired sphere size
		//first read the icosahedron
		//this is a mesh instance for now
		Mesh icosahedron = Util.readObjFile("Assets\\Models\\icosahedron.obj");
		//get vertices
		float[] vertices = icosahedron.vertices();
		for(int i = 0; i< vertices.length; i+=9) {
			//normalize the position
			Vector3f point = new Vector3f(vertices[i], vertices[i+1], vertices[i+2]);
			point.normalize();
			//now reset position and normal data
			vertices[i] = point.x * radius;
			vertices[i+1] = point.y * radius;
			vertices[i+2] = point.z * radius;
			
			//for normal data we can simply reuse point
			//because the normal vector for a point on a sphere is the distance from that point to the origin
			//can be thought of as the 3D analogue for tan(theta) giving the normal vector for a unit circle
			//but with 2 angles
			//essentially, no extra calculations are necessary to assign normals
			vertices[i+3] = point.x;
			vertices[i+4] = point.y;
			vertices[i+5] = point.z;
			
			//since the icospheres will be programatically generated, there is no need for texture coordinates
			//but to keep consistent with the mesh formatting, the texture coordinates become color (rgb)
			//for this a new shader program will be used with a different fragment shader for non-textured objects
			
			//for now just set the color to white
			vertices[i+6] = 1;
			vertices[i+7] = 0;
			vertices[i+8] = 0;
		}
		
		//now subdivide
		//first get the indices for the icosahedron
		int[] indices = icosahedron.indices();
		//create a list to hold the new vertices and indices
		List<Float> newVertices = new ArrayList<Float>();
		List<Integer> newIndices= new ArrayList<Integer>();
		//populate both lists
		for(int i= 0; i< vertices.length; i++) newVertices.add(vertices[i]);
		for(int i= 0; i< indices.length; i++) newIndices.add(indices[i]);
		//subdivide 
		for(int a =0; a< subdiv; a++) {
			//create a new list to hold the subdivided indices
			List<Integer> subdivIndices = new ArrayList<Integer>();
			for(int i= 0; i< newIndices.size(); i+=3) {
				
				//grab the 3 indices
				int[] face = {newIndices.get(i), newIndices.get(i+1), newIndices.get(i+2)};
				//construct the vector3f instances
				Vector3f[] originalTriangle = new Vector3f[3];
				for(int b = 0; b< face.length; b++) {
					originalTriangle[b] = new Vector3f(newVertices.get(face[b]*9), newVertices.get(face[b]*9+1) ,newVertices.get(face[b]*9+2));
				}
				
				//create the other 3 vector3f (midpoints of the 3 edges)
				Vector3f[] newInstances = new Vector3f[3];
				for(int b= 0; b< originalTriangle.length; b++) {
					//get the 2 points that need to be midpointed
					Vector3f one = originalTriangle[b];
					//mod 3 to wrap back around to 0
					Vector3f two = originalTriangle[(b+1)%3];
					//take the difference and half it
					Vector3f diff = new Vector3f(two).sub(one);
					diff.mul(0.5f);
					//then add to one to get the point
					newInstances[b] = new Vector3f(one).add(diff);
					//then normalize to radius
					newInstances[b].normalize();
				}
				//now each new point has been created, now what is required to add to the vertices list
				//and add the correct indices
				int[] correspondingIndices = new int[3];
				for(int b = 0;b < newInstances.length; b++) {
					//log the index
					correspondingIndices[b] = newVertices.size()/9;
					//then add the vertex
					newVertices.add(newInstances[b].x * radius);
					newVertices.add(newInstances[b].y * radius);
					newVertices.add(newInstances[b].z * radius);
					
					newVertices.add(newInstances[b].x);
					newVertices.add(newInstances[b].y);
					newVertices.add(newInstances[b].z);
					
					newVertices.add(1f);
					newVertices.add(1f);
					newVertices.add(1f);
				}
				
				//now create the indices that connect the points
				//so from 0,1,2
				//to 0,n1,n3 & n1,1,n2 & n1,n2,n3 & n2,n3,2
				subdivIndices.add(face[0]);
				subdivIndices.add(correspondingIndices[0]);
				subdivIndices.add(correspondingIndices[2]);
				
				subdivIndices.add(correspondingIndices[0]);
				subdivIndices.add(face[1]);
				subdivIndices.add(correspondingIndices[1]);
				
				subdivIndices.add(correspondingIndices[0]);
				subdivIndices.add(correspondingIndices[1]);
				subdivIndices.add(correspondingIndices[2]);
				
				subdivIndices.add(correspondingIndices[1]);
				subdivIndices.add(correspondingIndices[2]);
				subdivIndices.add(face[2]);
			}
			//set the new indices to the indices created by the subdivision
			newIndices = subdivIndices;
		}
		
		//construct the new vertices and indices array to create the mesh instance
		float[] verts = new float[newVertices.size()];
		for(int i= 0; i< verts.length; i++) {
			verts[i] = newVertices.get(i);
		}
		int[] inds = new int[newIndices.size()];
		for(int i = 0; i< inds.length; i++) {
			inds[i] = newIndices.get(i);
		}
		return new Sphere(verts, inds);
	}

}
