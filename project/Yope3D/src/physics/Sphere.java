package physics;

import java.util.ArrayList;
import java.util.List;

import org.joml.Vector3f;

import visual.Mesh;
import visual.Util;

//this class encapsulates the behavior of a sphere object
//this class extends mesh to provide additional functionality beyond rendering
//like collisions and mesh generation
public class Sphere extends Mesh {
	
	//create private constructor the creates based on mesh constuctor
	private Sphere(float[] vertices, int[] indices) {
		super(vertices, indices);
	}
	
	//public constructor that creates mesh and indices based on input
	public static Sphere genSphere(float radius, int subdiv) {
		//this code will generate an icosphere
		//an icosphere is a sphere approximation generated by taking an icosahedron, subdividing each triangle
		//into 4, then projecting the vertices onto the desired sphere size
		//first read the icosahedron
		//this is a mesh instance for now
		Mesh icosahedron = Util.readObjFile("Assets\\Models\\icosahedron.obj");
		//get vertices
		float[] vertices = icosahedron.vertices();
		for(int i = 0; i< vertices.length; i+=8) {
			//normalize the position
			Vector3f point = new Vector3f(vertices[i], vertices[i+1], vertices[i+2]);
			point.normalize();
			//now reset position and normal data
			vertices[i] = point.x * radius;
			vertices[i+1] = point.y * radius;
			vertices[i+2] = point.z * radius;
			
			//for normal data we can simply reuse point
			//because the normal vector is the gradient of the original curve
			//gradient of x^2 + y^2 + z^2 = r^2
			//gives partial x 2x, partial y 2y, partial z 2z
			//normalization cancels out the 2s and becomes x,y,z, the original point
			//essentially, no extra calculations are necessary to assign normals
			vertices[i+3] = point.x;
			vertices[i+4] = point.y;
			vertices[i+5] = point.z;
		}
		
		//now subdivide
		//first get the indices for the icosahedron
		int[] indices = icosahedron.indices();
		//create a list to hold the new vertices and indices
		List<Float> newVertices = new ArrayList<Float>();
		List<Integer> newIndices= new ArrayList<Integer>();
		//populate both lists
		for(int i= 0; i< vertices.length; i++) newVertices.add(vertices[i]);
		for(int i= 0; i< indices.length; i++) newIndices.add(indices[i]);
		//subdivide 
		for(int a =0; a< subdiv; a++) {
			//create a new list to hold the subdivided indices
			List<Integer> subdivIndices = new ArrayList<Integer>();
			for(int i= 0; i< newIndices.size(); i+=3) {
				
				//grab the 3 indices
				int[] face = {newIndices.get(i), newIndices.get(i+1), newIndices.get(i+2)};
				//construct the vector3f instances
				Vector3f[] originalTriangle = new Vector3f[3];
				for(int b = 0; b< face.length; b++) {
					originalTriangle[b] = new Vector3f(newVertices.get(face[b]*8), newVertices.get(face[b]*8+1) ,newVertices.get(face[b]*8+2));
				}
				
				//create the other 3 vector3f (midpoints of the 3 edges)
				//and the averaged texture coordinates
				Vector3f[] texCoords = new Vector3f[3];
				Vector3f[] newInstances = new Vector3f[3];
				for(int b= 0; b< originalTriangle.length; b++) {
					//get the 2 points that need to be midpointed
					Vector3f one = originalTriangle[b];
					//mod 3 to wrap back around to 0
					Vector3f two = originalTriangle[(b+1)%3];
					//take the difference and half it
					Vector3f diff = new Vector3f(two).sub(one);
					diff.mul(0.5f);
					//then add to one to get the point
					newInstances[b] = new Vector3f(one).add(diff);
					//then normalize
					newInstances[b].normalize();
					
					//now average the texture coordinates
					Vector3f t1 = new Vector3f(newVertices.get(face[b]*8 + 6), newVertices.get(face[b]*8 + 7), 0);
					int x = (b+1)%3;
					Vector3f t2 = new Vector3f(newVertices.get(face[x]*8 + 6), newVertices.get(face[x]*8 + 7), 0);
					texCoords[b] = new Vector3f(t1).add(t2);
					texCoords[b].mul(0.5f);
				}
				//now each new point has been created, now what is required to add to the vertices list
				//and add the correct indices
				int[] correspondingIndices = new int[3];
				for(int b = 0;b < newInstances.length; b++) {
					//log the index
					correspondingIndices[b] = newVertices.size()/8;
					//then add the vertex
					newVertices.add(newInstances[b].x * radius);
					newVertices.add(newInstances[b].y * radius);
					newVertices.add(newInstances[b].z * radius);
					
					//see above for why surface point can be reused for normal
					newVertices.add(newInstances[b].x);
					newVertices.add(newInstances[b].y);
					newVertices.add(newInstances[b].z);
					
					newVertices.add(texCoords[b].x);
					newVertices.add(texCoords[b].y);
				}
				
				//now create the indices that connect the points
				//so from 0,1,2
				//to 0,n1,n3 & n1,1,n2 & n1,n2,n3 & n2,n3,2
				subdivIndices.add(face[0]);
				subdivIndices.add(correspondingIndices[0]);
				subdivIndices.add(correspondingIndices[2]);
				
				subdivIndices.add(correspondingIndices[0]);
				subdivIndices.add(face[1]);
				subdivIndices.add(correspondingIndices[1]);
				
				subdivIndices.add(correspondingIndices[0]);
				subdivIndices.add(correspondingIndices[1]);
				subdivIndices.add(correspondingIndices[2]);
				
				subdivIndices.add(correspondingIndices[1]);
				subdivIndices.add(correspondingIndices[2]);
				subdivIndices.add(face[2]);
			}
			//set the new indices to the indices created by the subdivision
			newIndices = subdivIndices;
		}
		
		//construct the new vertices and indices array to create the mesh instance
		float[] verts = new float[newVertices.size()];
		for(int i= 0; i< verts.length; i++) {
			verts[i] = newVertices.get(i);
		}
		int[] inds = new int[newIndices.size()];
		for(int i = 0; i< inds.length; i++) {
			inds[i] = newIndices.get(i);
		}
		return new Sphere(verts, inds);
	}
	
	//uv sphere generation method
	//requires divisible by 2 slices parameter
	public static Sphere genSphere(int segments, int slices, float radius) {
		//this method will create rectangular faces around circles that increase and decrease in radius
		//done through double for loop of angles
		
		//positions can be found through polar -> rectangular conversions
		//normals are just positions
		//texture coordinates are angles mapped to 0->1 (trust)
		
		//one issue is that due to the linear interpolation opengl does on textures, the last segment (when joined with the first)
		//interpolates from a value close to 1 to 0, which creates this very bad texture distortion
		//to fix this, a duplicate seam is created, so in reality segments + 1 segments are created (that is why segments +1 is always used)
		
		//list of floats for vertices
		List<Float> vertices = new ArrayList<Float>();
		
		//generate angle steps
		float thetaStep = (float) Math.PI * 2;
		thetaStep /= segments;
		float phiStep = (float) Math.PI;
		phiStep /= slices;
		//run through the slices (vertical)
		for(int i= -slices/2; i<= slices/2; i++) {
			//calculate phi for this iteration
			float phi = i * phiStep;
			//calculate y
			float y = radius * (float) Math.sin(phi);
			//calculate texture coordinate v by normalizing angle from -slices/2 -> slices/2 to 0->1
			float v = (float) (i + slices/2);
			v /= (float) (slices);
			//calculate the new radius, used for x and z calculations
			float newRadius = radius * (float) Math.cos(phi);
			for(int j = 0; j< segments+1; j++) {
				//calculate theta for this iteration
				float theta = j * thetaStep;
				//x is just the radius times sin
				float x = newRadius * (float) Math.cos(theta);
				//z is just -radius times cos
				float z = newRadius * (float) Math.sin(theta);
				
				//calculate texture coordinate u by normalizing angle from 0->segments to 0->1
				float u = (float) (j) / (float) segments;
				
				
				//add to vertices
				//positions
				vertices.add(x);
				vertices.add(y);
				vertices.add(z);
				
				//normals (see above why surface point can be reused for normal)
				Vector3f normal = new Vector3f(x,y,z);
				normal.normalize();
				vertices.add(normal.x);
				vertices.add(normal.y);
				vertices.add(normal.z);
				
				//texture coordinates
				vertices.add(u);
				vertices.add(v);
			}
		}
		
		//list of integers for indices
		List<Integer> indices = new ArrayList<Integer>();
		//iterate through slices and segments
		for(int i =0 ;i< slices; i++) {
			for(int j =0; j< segments+1; j++) {
				//index is given by i*(segments+1) + j
				int index = i*(segments+1) + j;
				
				int plusOne = index+1;
				
				
				//form the quad
				indices.add(index);
				indices.add(index + segments +1);
				indices.add(plusOne);
				indices.add(plusOne + segments +1);
				indices.add(index + segments + 1);
				indices.add(plusOne);
			}
		}
		float[] data = new float[vertices.size()];
		for(int i =0; i< data.length ;i++) {
			data[i] = vertices.get(i);
		}
		int[] indexes = new int[indices.size()];
		for(int i =0; i< indexes.length ;i++) {
			indexes[i] = indices.get(i);
		}
		return new Sphere(data, indexes);
	}
}
